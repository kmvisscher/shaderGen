//
// Format.cpp
//
// $Id: //poco/1.4/Foundation/src/Format.cpp#7 $
//
// This file is modified by Zefiros Software!
//
// Library: Foundation
// Package: Core
// Module:  Format
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include "common/format.h"
#include "common/types.h"

#include <sstream>
#include <cstddef>
#include <ctype.h>

namespace Util
{
    namespace
    {
        void ParseFlags( std::ostream &str, std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt )
        {
            bool isFlag = true;

            while ( isFlag && itFmt != endFmt )
            {
                switch ( *itFmt )
                {
                case '-': str.setf( std::ios::left ); ++itFmt; break;

                case '+': str.setf( std::ios::showpos ); ++itFmt; break;

                case '0': str.fill( '0' ); str.setf( std::ios::internal ); ++itFmt; break;

                case '#': str.setf( std::ios::showpoint | std::ios::showbase ); ++itFmt; break;

                default:  isFlag = false; break;
                }
            }
        }


        void ParseWidth( std::ostream &str, std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt )
        {
            int width = 0;

            while ( itFmt != endFmt && isdigit( *itFmt ) )
            {
                width = 10 * width + *itFmt - '0';
                ++itFmt;
            }

            if ( width != 0 ) str.width( width );
        }


        void ParsePrec( std::ostream &str, std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt )
        {
            if ( itFmt != endFmt && *itFmt == '.' )
            {
                ++itFmt;
                int prec = 0;

                while ( itFmt != endFmt && isdigit( *itFmt ) )
                {
                    prec = 10 * prec + *itFmt - '0';
                    ++itFmt;
                }

                if ( prec >= 0 ) str.precision( prec );
            }
        }

        char ParseMod( std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt )
        {
            char mod = 0;

            if ( itFmt != endFmt )
            {
                switch ( *itFmt )
                {
                case 'l':
                case 'h':
                case 'L':
                case '?': mod = *itFmt++; break;
                }
            }

            return mod;
        }

        std::size_t ParseIndex( std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt )
        {
            int index = 0;

            while ( itFmt != endFmt && isdigit( *itFmt ) )
            {
                index = 10 * index + *itFmt - '0';
                ++itFmt;
            }

            if ( itFmt != endFmt && *itFmt == ']' ) ++itFmt;

            return index;
        }

        void PrepareFormat( std::ostream &str, char type )
        {
            switch ( type )
            {
            case 'd':
            case 'i': str << std::dec; break;

            case 'o': str << std::oct; break;

            case 'x': str << std::hex; break;

            case 'X': str << std::hex << std::uppercase; break;

            case 'e': str << std::scientific; break;

            case 'E': str << std::scientific << std::uppercase; break;

            case 'f': str << std::fixed; break;
            }
        }


        void WriteAnyInt( std::ostream &str, const ::boost::any &any )
        {
            if ( any.type() == typeid( char ) )
                str << static_cast<int>( boost::any_cast<char>( any ) );
            else if ( any.type() == typeid( signed char ) )
                str << static_cast<int>( boost::any_cast<signed char>( any ) );
            else if ( any.type() == typeid( unsigned char ) )
                str << static_cast<unsigned>( boost::any_cast<unsigned char>( any ) );
            else if ( any.type() == typeid( short ) )
                str << boost::any_cast<short>( any );
            else if ( any.type() == typeid( unsigned short ) )
                str << boost::any_cast<unsigned short>( any );
            else if ( any.type() == typeid( int ) )
                str << boost::any_cast<int>( any );
            else if ( any.type() == typeid( unsigned int ) )
                str << boost::any_cast<unsigned int>( any );
            else if ( any.type() == typeid( long ) )
                str << boost::any_cast<long>( any );
            else if ( any.type() == typeid( unsigned long ) )
                str << boost::any_cast<unsigned long>( any );
            else if ( any.type() == typeid( S64 ) )
                str << boost::any_cast<S64>( any );
            else if ( any.type() == typeid( U64 ) )
                str << boost::any_cast<U64>( any );
            else if ( any.type() == typeid( bool ) )
                str << boost::any_cast<bool>( any );
        }


        void formatOne( std::string &result, std::string::const_iterator &itFmt, const std::string::const_iterator &endFmt,
                        std::vector< boost::any >::const_iterator &itVal )
        {
            std::ostringstream str;

            try
            {
                ParseFlags( str, itFmt, endFmt );
                ParseWidth( str, itFmt, endFmt );
                ParsePrec( str, itFmt, endFmt );
                char mod = ParseMod( itFmt, endFmt );

                if ( itFmt != endFmt )
                {
                    char type = *itFmt++;
                    PrepareFormat( str, type );

                    switch ( type )
                    {
                    case 'b':
                        str << boost::any_cast<bool>( *itVal++ );
                        break;

                    case 'c':
                        str << boost::any_cast<char>( *itVal++ );
                        break;

                    case 'd':
                    case 'i':
                        switch ( mod )
                        {
                        case 'l': str << boost::any_cast<long>( *itVal++ ); break;

                        case 'L': str << boost::any_cast<S64>( *itVal++ ); break;

                        case 'h': str << boost::any_cast<short>( *itVal++ ); break;

                        case '?': WriteAnyInt( str, *itVal++ ); break;

                        default:  str << boost::any_cast<int>( *itVal++ ); break;
                        }

                        break;

                    case 'o':
                    case 'u':
                    case 'x':
                    case 'X':
                        switch ( mod )
                        {
                        case 'l': str << boost::any_cast<unsigned long>( *itVal++ ); break;

                        case 'L': str << boost::any_cast<U64>( *itVal++ ); break;

                        case 'h': str << boost::any_cast<unsigned short>( *itVal++ ); break;

                        case '?': WriteAnyInt( str, *itVal++ ); break;

                        default:  str << boost::any_cast<unsigned>( *itVal++ ); break;
                        }

                        break;

                    case 'e':
                    case 'E':
                    case 'f':
                        switch ( mod )
                        {
                        case 'l': str << boost::any_cast<long double>( *itVal++ ); break;

                        case 'L': str << boost::any_cast<long double>( *itVal++ ); break;

                        case 'h': str << boost::any_cast<float>( *itVal++ ); break;

                        default:  str << boost::any_cast<double>( *itVal++ ); break;
                        }

                        break;

                    case 's':
                        str << boost::any_cast<std::string>( *itVal++ );
                        break;

                    case 'z':
                        str << boost::any_cast<std::size_t>( *itVal++ );
                        break;

                    case 'I':
                    case 'D':
                    default:
                        str << type;
                    }
                }
            }
            catch ( ::boost::bad_any_cast & )
            {
                str << "[ERRFMT]";
            }

            result.append( str.str() );
        }
    }

    std::string Format( const std::string &fmt, const boost::any &value )
    {
        std::vector<boost::any> args;
        args.push_back( value );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }

    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7, const boost::any &value8 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        args.push_back( value8 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }
    
    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7, const boost::any &value8, const boost::any &value9 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        args.push_back( value8 );
        args.push_back( value9 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }
    
    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7, const boost::any &value8, const boost::any &value9, const boost::any &value10 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        args.push_back( value8 );
        args.push_back( value9 );
        args.push_back( value10 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }
    
    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7, const boost::any &value8, const boost::any &value9, const boost::any &value10,
                        const boost::any &value11 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        args.push_back( value8 );
        args.push_back( value9 );
        args.push_back( value10 );
        args.push_back( value11 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }
    
    std::string Format( const std::string &fmt, const boost::any &value1, const boost::any &value2,
                        const boost::any &value3, const boost::any &value4, const boost::any &value5, const boost::any &value6,
                        const boost::any &value7, const boost::any &value8, const boost::any &value9, const boost::any &value10,
                        const boost::any &value11, const boost::any &value12 )
    {
        std::vector<boost::any> args;
        args.push_back( value1 );
        args.push_back( value2 );
        args.push_back( value3 );
        args.push_back( value4 );
        args.push_back( value5 );
        args.push_back( value6 );
        args.push_back( value7 );
        args.push_back( value8 );
        args.push_back( value9 );
        args.push_back( value10 );
        args.push_back( value11 );
        args.push_back( value12 );
        std::string result = "";
        Format( result, fmt, args );
        return result;
    }
    
    void Format( std::string &result, const std::string &fmt, const std::vector<boost::any> &values )
    {
        std::string::const_iterator itFmt  = fmt.begin();
        std::string::const_iterator endFmt = fmt.end();
        std::vector<boost::any>::const_iterator itVal  = values.begin();
        std::vector<boost::any>::const_iterator endVal = values.end();

        while ( itFmt != endFmt )
        {
            switch ( *itFmt )
            {
            case '%':
                ++itFmt;

                if ( itFmt != endFmt && itVal != endVal )
                {
                    if ( *itFmt == '[' )
                    {
                        ++itFmt;
                        std::size_t index = ParseIndex( itFmt, endFmt );

                        if ( index < values.size() )
                        {
                            std::vector<boost::any>::const_iterator it = values.begin() + index;
                            formatOne( result, itFmt, endFmt, it );
                        }
                    }
                    else
                    {
                        formatOne( result, itFmt, endFmt, itVal );
                    }
                }
                else if ( itFmt != endFmt )
                {
                    result += *itFmt++;
                }

                break;

            default:
                result += *itFmt;
                ++itFmt;
            }
        }
    }


}
